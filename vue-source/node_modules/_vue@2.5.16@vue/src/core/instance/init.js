/* @flow */

import config from '../config'
import { initProxy } from './proxy'
import { initState } from './state'
import { initRender } from './render'
import { initEvents } from './events'
import { mark, measure } from '../util/perf'
import { initLifecycle, callHook } from './lifecycle'
import { initProvide, initInjections } from './inject'
import { extend, mergeOptions, formatComponentName } from '../util/index'
// vue实例编号
let uid = 0
// 定义初始化方法
export function initMixin (Vue: Class<Component>) {
  // Vue的原型新增_init方法，新建vue实例的时候内部调用此方法进行初始化
  Vue.prototype._init = function (options?: Object) {
    // 缓存实例为vm
    const vm: Component = this
    // a uid
    // 将当前uid赋值给vm实例的_uid属性作为编号，之后uid自增
    vm._uid = uid++

    let startTag, endTag
    // 如果不是生产环境并且开启了性能追踪，并且存在计算性能的函数,那么为每个vue实例定义测试性能的开始跟结束标签，然后记录开始时间节点，开始追踪
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    // 定义一个避免被观察到的标志,表示如果是vue的实例，则不需要被observe
    vm._isVue = true
    // merge options
    // 配置对象options是否存在并且options._isComponent为真时，直接进行属性赋值，否则启用选项动态合并(人为新建vue实例的时候应当是不会创建options._isComponent，所以可能是内部子组件创建是自动生成的)
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      // 因为动态选项合并非常缓慢，并且没有任何内部组件选项需要特殊处理，所以这里对内部组件的实例化做优化
      initInternalComponent(vm, options)
    } else {
      // 合并选项
      // options是new Vue(options)实例化传入的，
      // resolveConstructorOptions(vm.constructor)表示解析构造函数的options
      // vm.$options是用于当前Vue 实例的初始化选项
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    // 假如不是生产环境，对vm进行代理（proxy用来在语言层面上更改操作的行为）
    // 如果是生产环境，将vm赋值给vm._renderProxy，定义的这个vm._renderProxy是为后期render做准备的，
    // 作用是在render中将this指向vm._renderProxy,即指向vm，类似于我们常用的that = this
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    // 暴露出自身出来
    vm._self = vm
    // 为实例初始化生命周期中会用到的一些属性
    initLifecycle(vm)
    // 为实例初始化自定义事件
    initEvents(vm)
    // 为实例初始化一些渲染属性
    initRender(vm)
    // 调用beforeCreate生命周期钩子
    callHook(vm, 'beforeCreate')
    // 在数据观测前初始化injections，injections允许一个祖先组件向其所有子孙后代注入一个依赖
    // provide跟inject主要为高阶插件/组件提供用例，需要一起使用，不推荐直接用于应用程序代码
    initInjections(vm) // resolve injections before data/props
    // 初始化并观测数据,即处理prop、method、data、computed、watch
    initState(vm)
    // 在初始化data跟prop后再解析provide
    initProvide(vm) // resolve provide after data/props
    // 数据初始化处理完毕，调用created生命周期钩子
    callHook(vm, 'created')

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }
    // dom节点已存在则挂载
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
// 直接根据options选项填充属性到vue实例的配置对象，这样比动态枚举快很多
export function initInternalComponent (vm: Component, options: InternalComponentOptions) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  // doing this because it's faster than dynamic enumeration.
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode
  opts._parentElm = options._parentElm
  opts._refElm = options._refElm

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}

export function resolveConstructorOptions (Ctor: Class<Component>) {
  let options = Ctor.options
  // super关键字既可以当作函数使用，也可以当作对象使用
  // 当作函数调用时，代表父类的构造函数，子类构造函数必须调用一次super()函数,否则js引擎会报错,
  // 此时super内的this指向子类的实例，即相当于A.prototype.constructor.call(this)。（A表示父类）
  // 当作对象时，在普通方法中指向父类的原型对象，在静态方法中指向父类,此处表示父类的原型对象
  if (Ctor.super) {
    const superOptions = resolveConstructorOptions(Ctor.super)
    const cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      // 这里先用Ctor.super判断存不存在父类（或者说判断该类是否是Vue的子类）
      // 其次判断父类中的options有没有发生变化，因为存在这种情况Vue.extend(options);Vue.mixin(options);
      // 先拓展创建了子类，之后为父类（即Vue）混入了一些配置，所以实例化的时候需要判断是否更新子类的superOptions
      Ctor.superOptions = superOptions
      // check if there are any late-modified/attached options (#4976)
      // 修复resolveConstructorOptions函数丢失了构造函数后期注入的选项的问题
      const modifiedOptions = resolveModifiedOptions(Ctor)
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions)
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) {
        options.components[options.name] = Ctor
      }
    }
  }
  return options
}
// 遍历比对出发生改变的选项
function resolveModifiedOptions (Ctor: Class<Component>): ?Object {
  let modified
  const latest = Ctor.options
  const extended = Ctor.extendOptions
  const sealed = Ctor.sealedOptions
  for (const key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) modified = {}
      modified[key] = dedupe(latest[key], extended[key], sealed[key])
    }
  }
  return modified
}
// 比较得出已改变选项的最终值
function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    const res = []
    sealed = Array.isArray(sealed) ? sealed : [sealed]
    extended = Array.isArray(extended) ? extended : [extended]
    for (let i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i])
      }
    }
    return res
  } else {
    return latest
  }
}
