/* @flow */

import { extend, warn, isObject } from 'core/util/index'

/**
 * Runtime helper for rendering <slot>
 */
// 辅助渲染函数，用于处理<slot>标签
export function renderSlot (
  name: string,
  fallback: ?Array<VNode>,
  props: ?Object,
  bindObject: ?Object
): ?Array<VNode> {
  // 方法挂载在Vue.prototype下，创建实例时被实例继承，故这里的this指的是vue实例,scopedSlotFn是对应的具名slot标签的处理方法
  const scopedSlotFn = this.$scopedSlots[name]
  let nodes
  if (scopedSlotFn) { // scoped slot
    props = props || {}
    // 如果bindObject存在，合并bindObject跟props，返回处理后的虚拟节点
    // 根据警告提示可以判定，bindObject是作用域插槽绑定的域，是个对象，
    // props来源暂时不明，应该是个混入属性
    // scopedSlotFn是包装函数，因为作用域插槽的工作原理就是将插槽内容包括在一个传入单个参数的函数里，这就是那个函数
    // 作用域插槽的目的是为了让父组件插槽可以调用子组件的数据，所以这里需要包装一下
    // fallback是降级的默认值
    if (bindObject) {
      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        )
      }
      props = extend(extend({}, bindObject), props)
    }
    nodes = scopedSlotFn(props) || fallback
  } else {
    // 不存在scopedSlotFn，即不会发生跨域取数，那么从this.$slots中取出对应的虚拟节点来做处理
    // slotNodes._rendered用来检测重复的判断，this.$slots存的是解析获得的插槽内容
    const slotNodes = this.$slots[name]
    // warn duplicate slot usage
    // 警告重复插槽的使用
    if (slotNodes) {
      if (process.env.NODE_ENV !== 'production' && slotNodes._rendered) {
        warn(
          `Duplicate presence of slot "${name}" found in the same render tree ` +
          `- this will likely cause render errors.`,
          this
        )
      }
      slotNodes._rendered = true
    }
    nodes = slotNodes || fallback
  }
  // target暂时不知道有什么含义
  const target = props && props.slot
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}
