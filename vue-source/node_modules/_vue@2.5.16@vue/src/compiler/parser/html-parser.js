/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */
// 引入映射表构造器，空函数
import { makeMap, no } from 'shared/util'
// 引入判断非语句型标签的函数
import { isNonPhrasingTag } from 'web/compiler/util'

// Regular Expressions for parsing tags and attributes
// 用于分析标记和属性的正则表达式,就是匹配像这样形式的： name="value" 把正则表达式拆开，逐步分析匹配的字符
// ^\s*                                               零个或多个Unicode空白符开头
// ([^\s"'<>\/=]+)                                    一个或多个除Unicode空白符、双引号、单引号、斜杠、等于号之外的字符，即捕获name
// (?:                            
//    \s*(=)\s*                                       匹配等于号 =
//    (?:
//      "([^"]*)"+  |  '([^']*)'+  |  ([^\s"'=<>`]+)  匹配 "value" 或 'value' 或 value， 并捕获value
//    )      
// )?                                                 整个来看就是匹配 name = value 或者 name 
const attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/
// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
// 在xml规范中，定义了元素（或说标签）的命名规范, 但对于vue模板来说，我们可以强制使用一个简单的字符集
// 即 ncname 用来匹配模板中的标签,以a-zA-Z_开头，后接零个或多个任何\w - . 这些字符（\w等价于a-zA-Z0-9_），这里因为ncname定义为字符串，不是正则，故\w变为\\w
// 形如: a-sdad-sdasda
const ncname = '[a-zA-Z_][\\w\\-\\.]*'
// ncname会漏掉某些情况，
// qnameCapture 即为 
// (
//   (?:[a-zA-Z_][\w\-\.]*\:)?
//   [a-zA-Z_][\w\-\.]*
// )
const qnameCapture = `((?:${ncname}\\:)?${ncname})`
// startTagOpen = /^<((?:[a-zA-Z_][\w\-\.]*\:)?[a-zA-Z_][\w\-\.]*)/
// ^< 
// (
//   (?: 
//     [a-zA-Z_]
//     [\w\-\.]*
//     \:           符号 : 在正则中具有特殊含义，如 ?: 这样的， 单独出现没有特殊含义
//    )?
//   [a-zA-Z_] 
//   [\w\-\.]*
// )
// 匹配标签起始符跟标签名
const startTagOpen = new RegExp(`^<${qnameCapture}`)
// 匹配标签的结束符
const startTagClose = /^\s*(\/?)>/
// 匹配结束标签
const endTag = new RegExp(`^<\\/${qnameCapture}[^>]*>`)
// 匹配文档类型标记
const doctype = /^<!DOCTYPE [^>]+>/i
// #7298: escape - to avoid being pased as HTML comment when inlined in page
// 转义 - 避免在页面中内联时被当作HTML注释传递, #7298由之前的 /<!-/跟改为 /!\-/
// 匹配注释标签开头(可能匹配到文本注释或IE下的条件注释)
const comment = /^<!\--/
// 匹配条件注释,IE条件注释
// 形如: <!--[if IE 6]>......<![endif]-->，或者<!-- [if IE 6]>-->.....<!--<![endif]--> 
// 这里应该是匹配条件注释的结束标签
const conditionalComment = /^<!\[/
// 判断环境的编译器会不会捕获字符串中的空字符
// 在perl中是不会出现这样的情况的，js中的正则表达式作为perl的子集，部分功能可能有所出入
// 这里是判断正则表达式会不会捕获到间隔（或说交替）的中断
let IS_REGEX_CAPTURING_BROKEN = false
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === ''
})

// Special Elements (can contain anything)
// 特殊的元素（能包含任何东西）
// 判断是否是纯文本的元素标签
export const isPlainTextElement = makeMap('script,style,textarea', true)
const reCache = {}
// 实体编码转换表
const decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t'
}
const encodedAttr = /&(?:lt|gt|quot|amp);/g
const encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g

// #5992
// #5992表示应该忽略pre跟textarea标签之后的第一个LF（即换行符\n）
const isIgnoreNewlineTag = makeMap('pre,textarea', true)
const shouldIgnoreFirstNewline = (tag, html) => tag && isIgnoreNewlineTag(tag) && html[0] === '\n'
// 对属性进行解码
// 根据是否需要对属性中包含的换行符进行解码，调用不同的正则，来替换属性中的字符
// 某些浏览器在渲染视图时会对标签属性中的换行符跟缩进符进行编码处理，如a标签的href属性等，故有此判断
// 如果代码被浏览器编码了，不是原来的代码了，需要解码还原，这里针对换行符跟缩进符,其他的依旧是被解码的
function decodeAttr (value, shouldDecodeNewlines) {
  const re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr
  return value.replace(re, match => decodingMap[match])
}
// 解析html字符串，生成构造抽象语法树，html即为一开始传入的template
export function parseHTML (html, options) {
  // 标签栈，用于解析过程中临时保存遇到的嵌套的标签,如<div><span></span></div>,匹配到span标签时，将之前匹配的div先进栈保存
  const stack = []
  // options.expectHTML为true，根据平台的不同调用的文件不同，web下继承自baseOptions
  const expectHTML = options.expectHTML
  // options.isUnaryTag 为函数，用于判断是否是一元标签,根据平台的不同调用的文件不同，web下继承自baseOptions
  const isUnaryTag = options.isUnaryTag || no
  // 判断是否可以当做自闭合标签，根据平台的不同调用的文件不同，web下继承自baseOptions
  const canBeLeftOpenTag = options.canBeLeftOpenTag || no
  // 初始化解析位置
  let index = 0
  // last用于暂存剩下的未被解析的html字符串，lastTag用于存储匹配过程中匹配到的最后一个标签
  let last, lastTag
  // 状态初始化完毕后，从这里开始循环解析html
  while (html) {
    last = html
    // Make sure we're not in a plaintext content element like script/style
    // 确保我们没有使用script/style这样的纯文本内容元素
    // 如果没有匹配到的标签或者匹配到的标签是纯文本内容标签,那么寻找下一个标签起始(成对标签中的起始标签，自闭合标签)
    // 解析甫一开始，lastTag还是undefined，故刚开始会走这个分支，而后存在出栈入栈操作，lastTag的值也会变动
    if (!lastTag || !isPlainTextElement(lastTag)) {
      // 在html中寻找标签的起始位置，标签总是被<括号包裹的
      let textEnd = html.indexOf('<')
      // 如果一开始就遇到了可能是标签情况，匹配更多以区分类型
      if (textEnd === 0) {
        // Comment:
        // 如果是注释（可能是文本注释也可能是条件注释,如果是条件注释时，岂不是同样会被处理？那么下面再处理条件注释有何用处？）
        // 条件注释被当作文本注释，保留的话依旧会被渲染到浏览器，因此浏览器依旧能识别出
        if (comment.test(html)) {
          // 匹配注释的结束位置
          const commentEnd = html.indexOf('-->')
          // 如果找到了注释的结束位置，根据是否保留注释来处理（感觉好像除了模板本身写错，否则不会出现小于0的情况）
          if (commentEnd >= 0) {
            // options.shouldKeepComment即是vm.$options.comments,新建实例是由选项comments传入，为true时将保留模板中的html注释
            // 如果需要保留注释，那么把截取注释内容，转换为对象放入当前处理节点的子节点数组（即当作文本节点）
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd))
            }
            // 处理完注释后，更新html，跳出当前循环进入下一轮
            advance(commentEnd + 3)
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        // 感觉条件注释被上面的判断当作文本注释处理了，即好像永远不会走这个分支
        // <!--[if IE 6]>......<![endif]-->或者<!-- [if IE 6]>-->.....<!--<![endif]--> 、<!-- [if IE 6]>-->.....<![endif]--> 
        // 咦！假如说有两个并列组件，前一个组件包含了条件注释的头部，后一个组件包含了条件注释的尾部，emmm...
        // (有些极端情况是不需要考虑的，解析模板不是全能，所以有时模板写错时，页面渲染不出来或许就是这个原因,故而这个情况可能不在考虑范围内，只是钻牛角尖)
        // 只包含了条件注释的头部，那么因为匹配不到-->,不会被当作文本注释一起处理，就需要进一步判断是否是条件注释
        // 判断html是否含有<![，即可能是条件注释的结束符了，那么匹配完整的条件注释标签，截取更新html
        if (conditionalComment.test(html)) {
          const conditionalEnd = html.indexOf(']>')
          // 如果确定为条件注释结尾符，那么截取掉条件注释结尾符，进入下一轮
          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2)
            continue
          }
        }

        // Doctype:
        // 以<开头，不是注释的情况下，判断是否是文档类型声明,如果匹配得到，截取掉文档类型声明，进入下一轮
        const doctypeMatch = html.match(doctype)
        if (doctypeMatch) {
          advance(doctypeMatch[0].length)
          continue
        }

        // End tag:
        // 以<开头，不是注释也不是文档类型声明的情况下，判断是否是结束标签
        const endTagMatch = html.match(endTag)
        // 如果匹配到了结束标签,那么截取掉匹配到的结束标签,解析结束标签,进入下一轮
        if (endTagMatch) {
          // index是解析到的初始的html中的位置下标
          const curIndex = index
          advance(endTagMatch[0].length)
          // 解析结束标签,endTagMatch[1]是匹配到的标签的子分组，即去除<>号后剩下的那个元素
          parseEndTag(endTagMatch[1], curIndex, index)
          continue
        }

        // Start tag:
        // 以<开头，不是注释、不是文档类型、不是结束标签，那么尝试当作开始标签来解析
        // startTagMatch是解析生成的一个包含匹配标签信息的对象
        const startTagMatch = parseStartTag()
        if (startTagMatch) {
          handleStartTag(startTagMatch)
          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1)
          }
          continue
        }
      }

      let text, rest, next
      if (textEnd >= 0) {
        rest = html.slice(textEnd)
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1)
          if (next < 0) break
          textEnd += next
          rest = html.slice(textEnd)
        }
        text = html.substring(0, textEnd)
        advance(textEnd)
      }
      // 匹配不到尖括号<，等于说html中构不成标签，那么就不用据需解析了，html置为空字符串（会经由while判断跳出循环）
      if (textEnd < 0) {
        text = html
        html = ''
      }

      if (options.chars && text) {
        options.chars(text)
      }
    // 如果lastTag存在且不是纯文本标签
    } else {
      let endTagLength = 0
      const stackedTag = lastTag.toLowerCase()
      const reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'))
      const rest = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1')
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1)
        }
        if (options.chars) {
          options.chars(text)
        }
        return ''
      })
      index += html.length - rest.length
      html = rest
      parseEndTag(stackedTag, index - endTagLength, index)
    }

    if (html === last) {
      options.chars && options.chars(html)
      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
        options.warn(`Mal-formatted tag at end of template: "${html}"`)
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag()

  // 解析过程中的步进，即每解析了html中的n个字符，递增记录解析位置，并截掉解析过的字符
  function advance (n) {
    index += n
    html = html.substring(n)
  }
  // 解析模板中的起始标签,生成标签的抽象对象
  function parseStartTag () {
    // 匹配标签起始符<跟标签名(包含自定义标签名)
    const start = html.match(startTagOpen)
    // 匹配到了起始标签，把这个标签转换成抽象节点
    if (start) {
      const match = {
        tagName: start[1],
        attrs: [],
        start: index
      }
      advance(start[0].length)
      // 匹配到起始标签名后，接下去就是分析跟在其后的各个键值对属性
      let end, attr
      // 如果不是起始标签的结束符，那么匹配属性键值对，
      // 如果匹配到了键值对属性name = value,丢进刚创建的节点的attrs里保存
      // 一遍一遍匹配直到遇到起始标签结束符，或者找不到属性为止
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length)
        match.attrs.push(attr)
      }
      // 如果匹配到了起始结束标签，给新生成的match这个节点做个标记，区分是自闭合标签还是普通标签的起始标签
      // end[1]要么是 / 要么是 ''
      if (end) {
        match.unarySlash = end[1]
        // 截取掉解析完的模板字符串,返回解析出来的新节点对象
        advance(end[0].length)
        match.end = index
        return match
      }
      // 没有结束符，什么都不返回（错误会在渲染时被捕获,因此这里不用太担心）
    }
    // 匹配不到起始标签，什么都不做，什么都不返回
  }
  // 对解析出来的标签对象进行处理
  function handleStartTag (match) {
    // 缓存标签名
    const tagName = match.tagName
    // 缓存一元（自闭合）标签标志
    const unarySlash = match.unarySlash
    // expectHTML在web下是true(意思应该是表示希望得到html文本),
    // 但是一开始解析时lastTag是还不存在的，一下这两个分支语句都不会被执行
    if (expectHTML) {
      // 如果lastTag是 p 元素,并且tagNames是非语句型标签，那么立即结束p标签的解析
      // 即是说在html中，p标签是不允许包含非语句型标签的，一遇到这种情况，那么可能是前一个匹配到的标签（即 p）缺省了结束标签
      // 以至于匹配到了下一个代码块的起始标签，因此要清空标签栈先结束对p的解析
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag)
      }
      // 如果tagName可以被当作自闭合标签，并且跟之前匹配的标签是相同的标签,同理也先结束对之前标签的解析
      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
        parseEndTag(tagName)
      }
    }
    // 缓存自闭合标签标志
    // isUnaryTag用来检查是不是原生的自闭合标签,后面的!!unarySlash是对自定义标签的处理
    const unary = isUnaryTag(tagName) || !!unarySlash
    // 缓存匹配的标签对象中属性的个数
    const l = match.attrs.length
    const attrs = new Array(l)
    // 遍历属性数组，进一步对每一个属性解析
    for (let i = 0; i < l; i++) {
      const args = match.attrs[i]
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      // 对FF 下的bug做hack处理
      // FF下，在某些情况下，javascript正则表达式会捕获到间隔的中断(就是说正则表达式在匹配的过程中，在匹配到的结果中，
      // 某些情况下捕获到的结果会包含undefined这样不是期望的结果,undefined在这里就明显是一个中断)
      // 下面这些情况不单单是在FF下会有，因此这应当不是FF的bug，
      // 或者说只是正则表达式的定义跟执行过程导致（作者应该是想引申出一些现象，这些现象是正常的，而作者的意图是想把那些在FF下的错误解析转为正常现象）
      // 情况1：
      // var re = /(?:(ABC)|(123)){2}/;
      // var t = re.exec("ABC123")
      // var u = re.exec("123ABC")
      // t 为 [ "ABC123", undefined, "123" ]， u 为 [ "123ABC", "ABC", undefined ]
      // 这是因为分组的每次重复都会使内部捕获重置为undefined。（because each repetition of a quantifier resets the inner captures to undefined）
      // 也就是说，对于t，第一次捕获到ABC（表达式中的分组1）,第二次捕获到123，因此分组一的内部捕获被重置为undefined，故结果中分组的对应位置为undefined
      // 对于u, 第一次捕获到123（表达式中的分组2），第二次捕获到ABC,因此，分组二被重置为undefined
      // 情况2：
      // /(a*)*/.exec("b")，结果为[ "", undefined ]
      // 这是因为分组的最小重复次数0不能匹配到空字符串（because a quantifier with minimum 0 cannot match an empty string (unlike Perl, which matches it once).）
      // 情况3： 
      // /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")，结果为：[ "baaabaac", "ba", undefined, "abaac" ]
      // 这是因为（because captures inside (?!) aren't visible outside (unlike (?=)).）
      // (?!p)零宽负向先行断言:要求接下来的字符不与p匹配
      // (?=p)零宽正向先行断言:要求接下来的字符都与p匹配，但不能包括匹配p的那些字符，p在此处只作为锚字符定位，不作为匹配结果
      // 这里之所以会匹配到undefined,是因为位于零宽负向先行断言(?!)中的分组对于外部不可见,故在结果中分组2的位置为undefined

      // 这里的意思是如果正则表达式会把空字符串当作分组匹配到，并且属性解析匹配到的字符串中含有"",即name = "" 这样值为空字符串的情况
      // 那么需要删除掉匹配到的空字符串结果分组（这里的删除delete只是把数组中的''替换为undefined，并不会更改数组的长度）
      // 如： a = [0, 1], 经过delete a[0] 后，a = [undefined, 1]
      // args 即是attr = html.match(attribute)， 而 attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/
      // args是正则表达式match后的结果数组，[匹配到的整串, 属性名([^\s"'<>\/=]+), 等于号(=), 属性值([^"]*), 属性值([^']*), 属性值 ([^\s"'=<>`]+)]
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        // 这里的操作时如果(因为bug而把)属性值错误的匹配了空字符串，把它转成undefined正常显示,下面会涉及属性值的赋值
        if (args[3] === '') { delete args[3] }
        if (args[4] === '') { delete args[4] }
        if (args[5] === '') { delete args[5] }
      }
      // 缓存属性的值，这里''已被转为undefined，所以能取到正确的匹配到的属性值
      const value = args[3] || args[4] || args[5] || ''
      // 谷歌浏览器会对a标签的href属性的值进行编码操作（编码的意思是把人们看到的、能理解的字符转换成计算机代码,例如\n会被转为&#10;），a标签的href属性
      // 这里表示如果是谷歌浏览器，同时解析到a标签的href属性时，需要对其进行解码(template里的字符被浏览器编码过了，表示需要解码还原)
      // 其他的属性根据浏览器的不同来判断是否需要解码
      const shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines
      // 把属性转换为对象（这里就把name跟value分离开来了）
      attrs[i] = {
        name: args[1],
        // decodeAttr会对value中的 &lt; 等转换为 < 等， 而像 &#10; 、 &#09; 会根据shouldDecodeNewlines判断是否转换为 \n 、 \t
        // 属性值什么时候会包含这些 &lt; 呢？
        value: decodeAttr(value, shouldDecodeNewlines)
      }
    }
    // 如果解析到的标签不是一元的，即有开始标签跟结束标签,就可能会有嵌套的情况,那么就把它放入标签栈，并把lastTag置为tagName
    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })
      lastTag = tagName
    }
    // 传入start函数生成抽象节点
    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end)
    }
  }
  // 解析匹配到的结束标签，做相应的出入栈操作
  // 在匹配End Tag时调用，start是等于end等于index（解析原始html的位置记录）
  function parseEndTag (tagName, start, end) {
    // pos是用来遍历标签栈的临时下标，lowerCasedTagName用来保存标签的小写形式(html是大小写不敏感的)
    let pos, lowerCasedTagName
    // 起始start不存在，把start置为当前的解析位置
    if (start == null) start = index
    // 结束end不存在，把end置为当前的解析位置
    if (end == null) end = index
    // tagName即匹配到的那个结束标签,先转为小写形式
    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase()
    }

    // Find the closest opened tag of the same type
    // 因为存在标签嵌套，匹配到一个标签的结束标记后，(可能之前有处理过这个标签的子元素,导致这个标签进栈）,所以需要去栈中寻找最近的一个相同的起始标签
    // 存在tagName时，即解析匹配到了结束标签,那么遍历标签栈，查询最近一个相同的起始标签的位置
    if (tagName) {
      // 根据html的嵌套规则，解析时采用后进先出的规则，故遍历时按下标从大到小遍历
      for (pos = stack.length - 1; pos >= 0; pos--) {
        // 如果在栈中找到了相同的标签，那么跳出循环，此时pos是大于或等于0的
        // 栈中下标大于pos的都将被出栈（下标大于pos的标签都属于当前标签的子元素,当当前标签结束时，子元素也都是被处理完毕的，存在栈中的是自闭合标签或缺省结束标签的标签，只有开始标签没有结束标签）
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
        // 如果直到遍历结束都没有找到，此时pos小于0（在模板没有错误的情况下，有啥情况会出现pos小于0？）
      }
    } else {
      // If no tag name is provided, clean shop
      // pos等于0的情况下，在处理匹配下个标签之前标签栈是会被清空的，这里如果没有传入标签名时，为让pos为0，
      // 即没传入tagName时，表示要清空整个标签栈
      pos = 0
    }
    // 如果pos大于等于0，会清空
    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (let i = stack.length - 1; i >= pos; i--) {
        if (process.env.NODE_ENV !== 'production' &&
          (i > pos || !tagName) &&
          options.warn
        ) {
          // 下标大于pos的元素都是一些缺失了结束标签的元素，非生产环境下会警告
          // tagName不存在时，pos已经被置为0了，!tagName处理的是标签栈中第一个元素，因为第一个元素的下标是不会大于pos的，但是它也不被匹配
          // 内置的编译时options.warn是compile里的finalOptgions.warn = ( msg, tip ) => { (tip ? tip : errors).push(msg) }
          // 而compile是会暴露出去的(Vue.compile),所以外部调用Vue.compile时，如果有传warn属性,此处的warn就是用户自定义的warn，没传时就是finalOptgions.warn 
          // 而parse里warn = options.warn || baseWarn,也就是说baseWarn好像永远都不会被调用的
          // 所以这里只是把警告信息收集，待解析完毕返回之后，会在compileToFunctions函数中将信息打印出来
          options.warn(
            `tag <${stack[i].tag}> has no matching end tag.`
          )
        }
        if (options.end) {
          options.end(stack[i].tag, start, end)
        }
      }

      // Remove the open elements from the stack
      // 把栈的长度设为pos，即栈中的元素是从0到pos - 1， pos这个位置上的标签也会被删掉（因为匹配到了结束标签，这个标签也是解析完毕的）
      stack.length = pos
      lastTag = pos && stack[pos - 1].tag
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end)
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end)
      }
      if (options.end) {
        options.end(tagName, start, end)
      }
    }
  }
}
