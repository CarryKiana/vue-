/* @flow */

import { ASSET_TYPES } from 'shared/constants'
import { defineComputed, proxy } from '../instance/state'
import { extend, mergeOptions, validateComponentName } from '../util/index'

export function initExtend (Vue: GlobalAPI) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  // 每个实例构造函数（包括Vue）都有一个唯一的cid，这使我们能够通过原型继承创建包装过的子构造函数（子类）并缓存它们
  Vue.cid = 0
  let cid = 1

  /**
   * Class inheritance
   */
  // 类式继承,使用基础Vue构造器，创建一个“子类”
  Vue.extend = function (extendOptions: Object): Function {
    extendOptions = extendOptions || {}
    const Super = this
    const SuperId = Super.cid
    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
    // 如果之前有extend，返回之前extend后的类，避免多次extend
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name)
    }
    // 类式继承，即子类构造函数里借调父类构造函数
    const Sub = function VueComponent (options) {
      this._init(options)
    }
    // 类式继承修复原型构造函数指向问题
    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub
    // 赋予Sub子类cid标志，之后cid自增
    Sub.cid = cid++
    // 合并子类配置对象
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
    // 保存父类构造函数，即Vue
    Sub['super'] = Super

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    // 对于props和计算属性，我们在拓展的时候，在拓展原型上为Vue实例定义代理的getters
    // 这样能避免在创建每一个实例的时候都去调用Object.defineProperty
    if (Sub.options.props) {
      initProps(Sub)
    }
    if (Sub.options.computed) {
      initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    // 允许子类使用extend、mixin、use等方法,简单地说就是继承了部分父类的静态函数
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    // Sub的filter、component、directive方法都继承自父类,
    // 而谁调用Sub.component后创建出来的组件是保存在this.options[type + 's'][id]，即是保存在Sub.options上的,
    // 所以所这些是这个类Sub的私有资产
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    // 递归自查找,方便需要的时候引用自身
    if (name) {
      Sub.options.components[name] = Sub
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    // 在扩展时（即创建子类时）保留对父类options的引用,
    // 这样如果在调用子类创建实例的时候，能检测父类的选项是否有发生过改变，从而同步更新子类的配置
    // 向Vue.mixin，Vue.extend之类，对构造函数Vue的改变都应当被其子类继承，子类改变子类的子类也同样要改变,
    // 故在创建实例方法_init中有检查选项更改的步骤
    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    // 缓存构造函数，避免多次extend
    cachedCtors[SuperId] = Sub
    return Sub
  }
}
// 原型上代理_props,实例的原型即是构造函数的原型，所以把构造函数的配置对象上的prop属性挨个挂到原型上，
// 用构造函数去创建实例时，实例不用去做处理就能访问到这些属性
function initProps (Comp) {
  const props = Comp.options.props
  for (const key in props) {
    proxy(Comp.prototype, `_props`, key)
  }
}
// 原型上定义computed,所以把构造函数的配置对象上的computed属性挨个挂到原型上，
// 用构造函数去创建实例时，实例不用去做处理就能访问到这些属性
function initComputed (Comp) {
  const computed = Comp.options.computed
  for (const key in computed) {
    defineComputed(Comp.prototype, key, computed[key])
  }
}
