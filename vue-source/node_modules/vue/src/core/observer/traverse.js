/* @flow */

import { _Set as Set, isObject } from '../util/index'
import type { SimpleSet } from '../util/index'
// Vnode是个虚拟节点的类，emmm...先略过这一部分
import VNode from '../vdom/vnode'

const seenObjects = new Set()

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
// 递归地遍历一个对象以调用所有转换的getter，以便将对象中的每个嵌套属性收集为“深度”依赖项
export function traverse (val: any) {
  _traverse(val, seenObjects)
  seenObjects.clear()
}
// 内部递归遍历方法
function _traverse (val: any, seen: SimpleSet) {
  let i, keys
  const isA = Array.isArray(val)
  // 不是数组并且不是对象 或者
  // val是一个被冻结的对象 或者
  // val是一个虚拟节点
  // 这些情况不用遍历，直接返回
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  // __ob__是Vue对数据监控添加的属性
  // 也就是说，假如val是一个被监控的对象，那么看一看set里之前有没有处理过它，
  // 没有的话就把它的dep.id加入set（表示处理过了,下次进来判断到处理过的就直接返回不用处理了）,再继续之后的处理逻辑
  if (val.__ob__) {
    const depId = val.__ob__.dep.id
    if (seen.has(depId)) {
      return
    }
    seen.add(depId)
  }
  // 如果是数组，按遍历数组的形式递归遍历每一个元素
  if (isA) {
    i = val.length
    while (i--) _traverse(val[i], seen)
    // 如果是对象，取出对象的key组成数组，再遍历每个key对应的值
  } else {
    keys = Object.keys(val)
    i = keys.length
    while (i--) _traverse(val[keys[i]], seen)
  }
}
