/* @flow */

import config from '../config'
import { noop } from 'shared/util'

export let warn = noop
export let tip = noop
export let generateComponentTrace = (noop: any) // work around flow check
export let formatComponentName = (noop: any)
// 生产环境的话warn跟tip等都是空函数，不是的话调用的话则会做相应操作
if (process.env.NODE_ENV !== 'production') {
  // 判断是否存在console对象
  const hasConsole = typeof console !== 'undefined'
  // 连字符命名转成驼峰式命名
  const classifyRE = /(?:^|[-_])(\w)/g
  const classify = str => str
    .replace(classifyRE, c => c.toUpperCase())
    .replace(/[-_]/g, '')
  // 重写warn方法，如果存在vm实例，形成对实例的组件跟踪（体现在页面上就是一报错会从当前组件到根组件的显示）
  // 如果自定义了警告方法,则将信息传入自定义方法，否则存在console对象同时没有取消警告就直接调用console对象的方法打印输出
  warn = (msg, vm) => {
    const trace = vm ? generateComponentTrace(vm) : ''

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace)
    } else if (hasConsole && (!config.silent)) {
      console.error(`[Vue warn]: ${msg}${trace}`)
    }
  }
  // 重写tip方法,除了没有自定义的方法，其余处理同warn
  tip = (msg, vm) => {
    if (hasConsole && (!config.silent)) {
      console.warn(`[Vue tip]: ${msg}` + (
        vm ? generateComponentTrace(vm) : ''
      ))
    }
  }
  // 对组件名称进行格式化
  formatComponentName = (vm, includeFile) => {
    // 如果是根组件，转化为'<Root>'
    if (vm.$root === vm) {
      return '<Root>'
    }
    // 推断组件名称
    // 首先尝试从组件的配置对象里获取信息，判断vm是不是函数并且vm.cid不为null(vm为什么会出现是函数的情况，vm.cid代表啥?)
    // 如果vm是函数并且vm.cid不为null，那么取vm的配置对象vm.options
    // 否则的话判断一下vm是不是vue实例,如果是的话取vm的配置对象vm.$options或者其构造函数的配置对象vm.constructor.options
    // 都不是的话取vm或者{}(防报错)
    const options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm || {}
    // 获取转换前的组件名称,可能为配置对象属性options.name或者options._componentTag,又或者是组件对应的文件名
    let name = options.name || options._componentTag
    const file = options.__file
    if (!name && file) {
      const match = file.match(/([^/\\]+)\.vue$/)
      name = match && match[1]
    }
    // 推断出有组件名称的话转换成驼峰式命名，没推断出来的话用匿名的<Anonymous>来代替
    // 存在文件名并且需要输出文件名的话就显示文件名
    return (
      (name ? `<${classify(name)}>` : `<Anonymous>`) +
      (file && includeFile !== false ? ` at ${file}` : '')
    )
  }
  // 对某个字符串重复，这里用像右位移的操作可能是想减少操作次数,因为如果n>1的话，重复的时候会将之前的一起重复，如第一次是a, 第二次是aa，第三次就是aaaa
  const repeat = (str, n) => {
    let res = ''
    while (n) {
      if (n % 2 === 1) res += str
      if (n > 1) str += str
      n >>= 1
    }
    return res
  }
  // 报错信息中出现的对组件位置的跟踪
  generateComponentTrace = vm => {
    // 假如是vue实例同时存在父组件的话，生成从当前组件到根组件的树结构信息,否则的话直接返回格式化的名称
    if (vm._isVue && vm.$parent) {
      // 初始化树结构
      const tree = []
      // 当前的递归序列(或者说层级)初始化(数组下标不代表就是递归层级)
      let currentRecursiveSequence = 0
      // 一开始进入while循环的时候不走if，直接就把vm压入数组中，然后vm变为父组件，下一个循环将对父组件判断,之后的循环都会走if(tree.length始终大于0了)
      while (vm) {
        if (tree.length > 0) {
          // 缓存当前树结构中最后一个对象,用来与当前处理的vm做比较
          const last = tree[tree.length - 1]
          if (last.constructor === vm.constructor) {
            // 如果树结构中最后一个对象跟当前vm的构造函数相同，那么递归序列自增，同时循环条件vm指向其父组件,退出当前循环进入下一轮循环去判断
            // 这里可能是处理相同组件互相嵌套的情况，即子组件跟父组件都是同一个组件，那么与其重复的去显示，记录其递归的层级明显更简洁(至少看上去舒服)
            // 为什么可以用constructor来做判断条件,相同的组件constructor肯定相同，不同的组件constructor就不同？是否会存在其他constructor相同的情况？
            currentRecursiveSequence++
            vm = vm.$parent
            continue
          } else if (currentRecursiveSequence > 0) {
            // 如果树结构中最后一个对象跟当前vm的构造函数不同，即不是同一组件,同时递归序列大于0，即说明之前遍历中存在相同组件嵌套，至此相同组件的嵌套结束，
            // 那么把树结构中最后一个对象显示成数组的形式，重置递归序列,再把当前的vm压入树中,改变vm进入下一轮循环
            tree[tree.length - 1] = [last, currentRecursiveSequence]
            currentRecursiveSequence = 0
          }
          // 其余情况直接压入树中，改变vm进入下一轮循环
        }
        tree.push(vm)
        vm = vm.$parent
      }
      // 循环结束就生成了从当前报错组件到根组件的一个路径数组,再把数组中每一个组件进行格式化转成字符串标志信息返回
      return '\n\nfound in\n\n' + tree
        .map((vm, i) => `${
          i === 0 ? '---> ' : repeat(' ', 5 + i * 2)
        }${
          Array.isArray(vm)
            ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)`
            : formatComponentName(vm)
        }`)
        .join('\n')
    } else {
      return `\n\n(found in ${formatComponentName(vm)})`
    }
  }
}
