/* @flow */

import { warn } from './debug'
import { observe, toggleObserving, shouldObserve } from '../observer/index'
import {
  hasOwn,
  isObject,
  toRawType,
  hyphenate,
  capitalize,
  isPlainObject
} from 'shared/util'
// 定义prop的形状
// prop.type可以是任何原生构造函数的一种,任何自定义构造函数，或者前述内容任意组成的数组
// prop.default为prop指定一个默认值，若prop的值没有被传入，会使用默认值，如果值是数组或对象等引用类型，必须写成函数返回一个副本
// prop.required定义prop是否是必填项
// prop.validator会验证prop的值
type PropOptions = {
  type: Function | Array<Function> | null,
  default: any,
  required: ?boolean,
  validator: ?Function
};
// 确定prop的value值
// 判断prop是否可以为Boolean类型，分以下3种情况
// 1、如果prop可以是Boolean类型，但是测试数据跟默认值都没有提供，那么暂定value值为false
// 2、如果prop可以是Boolean类型，但是测试数据提供的是空字符串（String类型）
//    则判断prop是否可以是String类型，不能是String或者可以是String但是Boolean比较优先，那么暂定value为true,
//    反之，String类型比Boolean类型优先，不做处理,此时value暂定为空字符串''
// 3、如果prop可以是Boolean类型，测试数据提供的值value为连字符化后的prop的键key（value === hyphenate(key)），
//    那么同样先判断一下prop是否可以是String类型，不能是String或者可以是String但是Boolean比较优先，那么value的值为true，
//    反之，String类型比Boolean类型优先，此时value的值为连字符化后的prop的键key
// 4、如果prop不能是Boolean类型，value依旧是测试数据propsData[key]
// 经过对Boolean、String类型的判断，此时的value的值为true、false或者propsData[key](包含特例空字符串跟hyphenate(key),但这两种情况在Boolean优先级较高时会转为true)，
// 接下去判断value是否是undefined（propsData[key]=== undefined，即prop不允许Boolean类型，并且没有提供测试数据）,尝试获取默认值
export function validateProp (
  key: string,
  propOptions: Object,
  propsData: Object,
  vm?: Component
): any {
  // 缓存该项prop的配置
  const prop = propOptions[key]
  // 判断prop提供数据上是否有这个值
  const absent = !hasOwn(propsData, key)
  // 缓存该项prop的提供数据
  let value = propsData[key]
  // boolean casting
  // 判断prop的类型是否包含Boolean
  const booleanIndex = getTypeIndex(Boolean, prop.type)
  // 如果prop.type包含Boolean，即prop的值可以是Boolean值,那么尝试对prop的值进行确定
  if (booleanIndex > -1) {
    // 如果没有提供测试数据并且prop也不具备默认值，那么value的值为false
    if (absent && !hasOwn(prop, 'default')) {
      value = false
    // 如果提供的value是空字符串或者value不是空字符串（不是空字符串时把key转成连字符当作value的值）
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      // 布尔值只比value为空字符串或连字符的key这两种权限有更高的优先级，即这两种情况下优先布尔取值
      // 在prop.type里查询String的下标,如果String不在prop.type里或者Boolean比String的优先级高（谁在prop.type中排前面谁就高，手动滑稽）
      // 就把value的值设为true
      const stringIndex = getTypeIndex(String, prop.type)
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true
      }
    }
  }
  // check default value
  // 没有提供数据，也推断不出value的值时，尝试获取默认值
  if (value === undefined) {
    // 获取默认值
    value = getPropDefaultValue(vm, prop, key)
    // since the default value is a fresh copy,
    // make sure to observe it.
    // 由于默认值是一个新副本，请确保观测它
    // 默认值是一个对象或数组时，会包装成一个函数返回，这里会对其进行观测以便依赖收集
    // 如果是像function() { return {}  }时，是对函数中返回的{}做数据观测，
    // 1、假如不去改变这个数据时，观测与否两说，prop本来就不能被修改，而{}在function里，形成闭包，这里不会被修改，
    // 但不确保会对vm._prop[key](vm._prop[key]是对象)里的某个属性做修改
    // 2、遇见这种情况:var a = { b: 1 }, function() { return a },确保对a进行观测，a里的属性变更能被观测到
    // 3、还有这种情况，var a = { b: 1 },vue实例1：function() { return a },vue实例2： function() { return a },
    // 两个实例同时引用了一个数据源,observe(a)只会对a绑定一个观测实例，一个实例一个观察者watcher，在初始化的时候，a触发的依赖收集
    // 会同时（或者说随着vue实例的初始化依次）被放入每个watcher的栈中，触发依赖收集一起被放入nextTick的执行函数队列中，
    // 随着事件循环一起执行（nextTick在页面上具有唯一的命名空间，不管页面上有多少个vue实例，nextTick只有一个）
    const prevShouldObserve = shouldObserve
    toggleObserving(true)
    observe(value)
    toggleObserving(prevShouldObserve)
  }
  if (
    process.env.NODE_ENV !== 'production' &&
    // skip validation for weex recycle-list child component props
    // 跳过WEEX回收列表子组件的验证
    !(__WEEX__ && isObject(value) && ('@binding' in value))
  ) {
    assertProp(prop, key, value, vm, absent)
  }
  return value
}

/**
 * Get the default value of a prop.
 */
// 获取prop的默认值
function getPropDefaultValue (vm: ?Component, prop: PropOptions, key: string): any {
  // no default, return undefined
  // 没有默认值，返回undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  const def = prop.default
  // warn against non-factory defaults for Object & Array
  // 默认值是对象或数组时，需用工厂函数包装
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    // 引用类型需写成函数的形式返回一个副本
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    )
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  // 原始的prop值在之前的渲染中还是undefined，返回之前的默认值来避免触发不必要的观察
  // 这个地方分情况来讨论
  // 1、vm.$options.propsData[key]一定不会等于undefined，因为不等于undefined的时候在函数外已被拦截
  // 2、实例初始化的时候，vm._props={},之后每处理一个key才会在vm._props定义一个key属性，
  // 也就是说,此时vm._props[key]一定时undefined的，不会走if里面的逻辑，返回的是prop的默认值，默认值没有响应式化，不会触发观察
  // 3、数据更新模板重新渲染的时候，vm._props[key] !== undefined，执行if逻辑，返回之前的缓存
  // 非根组件实例初始化的时候prop不会被观测,initProps:
  // if (!isRoot) {
  //   toggleObserving(false)
  // }
  // 即在非根组件中，访问vm._props[key]时不会触发依赖收集,
  // 而在validateProp函数中,有
  // toggleObserving(true);observe(value)
  // 即如果访问vm._props[key]中的某个属性是会触发依赖收集的（vm._props[key]是个对象）
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
// 断言prop是否有效
function assertProp (
  prop: PropOptions,
  name: string,
  value: any,
  vm: ?Component,
  absent: boolean
) {
  // prop必需，但没有提供数据,警告
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    )
    return
  }
  // prop是非必需，同时没有提供数据，不用判断直接返回
  if (value == null && !prop.required) {
    return
  }
  // 缺少type的情况下会在初始化时被规范转化为type = null
  let type = prop.type
  // valid为false表示无效，会触发警告,如果type是原生构造函数类型，自定义函数类型或数组，此时valid肯定是false
  // type === true是为了防止type = true这种极端情况，这里相当于只是确定初始值,而后进一步确定验证
  let valid = !type || type === true
  const expectedTypes = []
  // type存在时，根据type是数组还是某一构造函数类型进一步判断
  if (type) {
    // 如果不是数组时，存进数组转成数组形式
    if (!Array.isArray(type)) {
      type = [type]
    }
    // 遍历数组，确定valid的值，直到遍历完毕或者valid为true，即确定prop合法有效
    for (let i = 0; i < type.length && !valid; i++) {
      const assertedType = assertType(value, type[i])
      expectedTypes.push(assertedType.expectedType || '')
      valid = assertedType.valid
    }
  }
  // 类型检查失败，警告
  if (!valid) {
    warn(
      `Invalid prop: type check failed for prop "${name}".` +
      ` Expected ${expectedTypes.map(capitalize).join(', ')}` +
      `, got ${toRawType(value)}.`,
      vm
    )
    return
  }
  // prop自定义检查
  const validator = prop.validator
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      )
    }
  }
}

const simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/
// prop的类型断言
function assertType (value: any, type: Function): {
  valid: boolean;
  expectedType: string;
} {
  let valid
  // 获取类型,以此作为期望的类型
  const expectedType = getType(type)
  // 如果期望的类型是原生构造函数类型,判断传入的数据是否符合类型
  if (simpleCheckRE.test(expectedType)) {
    const t = typeof value
    valid = t === expectedType.toLowerCase()
    // for primitive wrapper objects
    // 其他的基本的包装对象再做进一步判断
    if (!valid && t === 'object') {
      valid = value instanceof type
    }
  // 如果期望的类型是对象，判断传入的数据是不是js纯对象
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value)
  // 如果期望的类型是数组，判断传入的数据是不是数组
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value)
  // 其他的如自定义构造函数用instanceof判断
  } else {
    valid = value instanceof type
  }
  // 返回判断结果跟期望类型
  return {
    valid,
    expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
// 使用函数字符串化后的名称来检查内置类型，因为在不同的vms/iframes之间运行时，简单的相等性比较将失效
// 不同的环境下的两个一样形状的对象是不同的，比如两个窗口下的window对象，它们是完完全全不同的两个东西，
// 因此单纯的用字符串化为原始值来做比较
function getType (fn) {
  const match = fn && fn.toString().match(/^\s*function (\w+)/)
  return match ? match[1] : ''
}
// 获取类型后比较类型是否相同
function isSameType (a, b) {
  return getType(a) === getType(b)
}
// 例：getTypeIndex(String, prop.type)
// 
function getTypeIndex (type, expectedTypes): number {
  // prop.type可以是构造函数组成的数组或构造函数名，
  // prop.type不是数组时，比较类型是否相同（传入对象等其他不符合的格式不用考虑，因为肯定会恒返回-1）
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  // prop.type是数组时,遍历数组，确定类型是否在数组中存在
  for (let i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}
