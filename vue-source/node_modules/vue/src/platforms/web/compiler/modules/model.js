/* @flow */

/**
 * Expand input[v-model] with dyanmic type bindings into v-if-else chains
 * Turn this:
 *   <input v-model="data[type]" :type="type">
 * into this:
 *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
 *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
 *   <input v-else :type="type" v-model="data[type]">
 */
// getAndRemoveAttr删除并返回attrsList上的属性
// getBindingAttr获取并解析v-bind属性
// baseWarn打印编译错误
import {
  addRawAttr,
  getBindingAttr,
  getAndRemoveAttr
} from 'compiler/helpers'
// 引入编译解析辅助工具
import {
  processFor,
  processElement,
  addIfCondition,
  createASTElement
} from 'compiler/parser/index'
// 此处的preTransformNode是用来解析v-model的,v-model用于在表单控件上创建双向绑定
// 工作方式随表单控件类型的不同而不同,限制标签类型为：input、select、textarea、components组件
function preTransformNode (el: ASTElement, options: CompilerOptions) {
  // 这里只对input标签做处理？
  if (el.tag === 'input') {
    // 缓存el的属性映射表
    const map = el.attrsMap
    // 若属性中不存在v-model，则不用处理直接返回
    if (!map['v-model']) {
      return
    }
    // 若属性中存在v-model属性，继续判断
    let typeBinding
    // 若存在动态绑定的type类型属性,缓存到typeBinding中
    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type')
    }
    // 若不存在静态类型属性，也不存在动态类型属性，尝试从v-bind对象中解析，如果存在v-bind的话
    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = `(${map['v-bind']}).type`
    }
    // 以上确认了动态属性type是否存在，若存在则进一步分类型来处理
    // input具有多种类型
    if (typeBinding) {
      // 获取缓存v-if属性（获取后同时从attrsList跟attrsMap上删除）
      const ifCondition = getAndRemoveAttr(el, 'v-if', true)
      // 如果存在v-if属性，用&&()包裹（这个应该是拼接成判断语句的）
      const ifConditionExtra = ifCondition ? `&&(${ifCondition})` : ``
      // 用hasElse标志el上是否存在v-else属性
      const hasElse = getAndRemoveAttr(el, 'v-else', true) != null
      // 缓存v-else-if属性
      const elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true)
      // 因为这里input的属性是动态的，所以克隆出了不同类型的节点来处理不同的类型
      // 1. checkbox
      // 克隆出一个节点来处理动态type为checkbox的情况
      const branch0 = cloneASTElement(el)
      // process for on the main node
      // 在克隆出来的主节点上处理v-for属性（解析出v-for的中的别名、key等，当作el的属性挂载在el上）
      processFor(branch0)
      // 为克隆出来的节点branch0添加type属性为checkbox,即同时把type:checkbox加入到了attrsList跟attrsMap上
      addRawAttr(branch0, 'type', 'checkbox')
      // 处理节点branch0上attrsList上的属性
      processElement(branch0, options)
      // 处理完节点branch0上的属性后，给它打上处理完毕的标志，防止重复处理
      branch0.processed = true // prevent it from double-processed
      // 因为input的动态类型type改变时是用克隆出来的节点去替换的，所以需要判断，故
      // 在节点的if条件上拼接上type类型判断（之前加的&&()作用在此）
      branch0.if = `(${typeBinding})==='checkbox'` + ifConditionExtra
      // 把节点branch0渲染的条件添加进节点的条件数组(即当符合条件exp时，用block引用的节点来渲染视图)
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      })
      // 2. add radio else-if condition
      // 另外克隆出一个节点用来处理动态type为radio的情况
      const branch1 = cloneASTElement(el)
      // 因为v-for已经在作为克隆主体的branch0中处理了，作为节点副本的branch1不需要在处理，
      // 故直接在branch1中删除掉v-for属性
      getAndRemoveAttr(branch1, 'v-for', true)
      // 为克隆出来的节点branch1添加type属性为radio
      addRawAttr(branch1, 'type', 'radio')
      // 处理branch1上的attrsList中的属性
      processElement(branch1, options)
      // 把节点branch1渲染的条件添加进节点的条件数组
      addIfCondition(branch0, {
        exp: `(${typeBinding})==='radio'` + ifConditionExtra,
        block: branch1
      })
      // 3. other
      // 对于除了checkbox、radio的其他type类型，统一克隆出一个节点branch2来处理
      const branch2 = cloneASTElement(el)
      // 从branch2上删除掉v-for属性
      getAndRemoveAttr(branch2, 'v-for', true)
      // 为克隆出来的节点branch2添加type属性，属性就是动态绑定的typeBinding
      addRawAttr(branch2, ':type', typeBinding)
      // 处理branch2上attrsList中的属性
      processElement(branch2, options)
      // 把节点branch2渲染的条件添加进节点的条件数组
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      })
      // 设置节点的else分支条件标志跟分支条件语句，假如有的话
      if (hasElse) {
        branch0.else = true
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition
      }
      // 返回处理后的结果
      return branch0
    }
    // type不是动态绑定的不会预处理
  }
  // v-model不是绑定在input上的不会预处理
}
// 克隆出一个抽象节点
function cloneASTElement (el) {
  // 以当前节点的数据，克隆出一个节点
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

export default {
  preTransformNode
}
