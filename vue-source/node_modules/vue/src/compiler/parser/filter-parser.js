/* @flow */
// 用来匹配有效的分隔字符串
// 即匹配a-zA-Z0-9 . + - _ $ ] 这些，用于解析表达式
const validDivisionCharRE = /[\w).+\-_$\]]/
// 用于解析抽象语法树绑定到动态属性的表达式（解析v-bind绑定的值）
// v-bind: / : 动态的绑定一个或多个特性，或一个组件prop到表达式
// 没有参数时，可以绑定到一个包含键值对的对象，此时class、style绑定不支持数组跟对象
// 即这里把特性当作了参数，有参数时如：v-bind:src="image",无参数时形如：v-bind="{ id: 'id'}"
// 修饰符：
// .prop 被用于绑定DOM属性（property）
// .camel 将连字符形式的特性名转换为驼峰式,使用字符串模板或通过vue-loader/vueify编译时，无需使用 .camel
// .sync 语法糖，会拓展成一个更新父组件绑定值的v-on侦听器

// 对表达式进行解析
// 经过把template模板解析为抽象语法树ast后，exp是某个属性的值，但此时exp依旧是个字符串，这里进一步对exp进行分析
export function parseFilters (exp: string): string {
  // 初始化
  // 以下4个以in开头的变量都是对前一个判断字符的标记,单引号、双引号、反引号、表达式斜杠总是成对出现的
  let inSingle = false // 判断接下来的字符是否是包在单引号里的
  let inDouble = false // 判断接下来的字符是否是包在双引号里的
  let inTemplateString = false // 判断接下来的字符是否是包在反引号里的
  let inRegex = false // 判断接下来的字符是否是包在正则表达式里的
  // 花括号、方括号、圆括号也是成对出现，但括号允许嵌套，故以下3个是对嵌套层级的记录
  let curly = 0 // 记录花括号的嵌套层数
  let square = 0 // 记录方括号的嵌套层数
  let paren = 0 // 记录圆括号的嵌套层数
  let lastFilterIndex = 0
  // c 表示当前正在判断的字符的Unicode编码, prev 表示当前字符之前的那个字符的Unicode编码
  // i 是遍历下标， expression用来存储解析得出的表达式，filters保存解析出的过滤器函数
  let c, prev, i, expression, filters
  // 逐个字符的判断其Unicode编码，分析exp中出现的特定字符
  for (i = 0; i < exp.length; i++) {
    // 缓存之前的字符的编码,初始的时候 prev 跟 c 都是undefined
    prev = c
    // 获取当前字符的Unicode编码
    c = exp.charCodeAt(i)
    // 0x5C 即 92，反斜杠 \ 的Unicode编码，联立判断是为了确定不是转义字符，而是真正的分隔符
    // 0x27 即 39，单引号 ' 的Unicode编码
    // 0x22 即 34，双引号 " 的Unicode编码
    // 0x60 即 96，反引号 ` 的Unicode编码
    // 0x2f 即 47，  斜杠 / 的Unicode编码
    // 0x7C 即 124， 竖杠 | 的Unicode编码， 或者称 | 为管道字符

    // 如果之前标记了字符是处于单引号字符包裹中的，而当前字符是非转义的单引号，那么结束单引号标记(成对匹配，结束字符串的引用)
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) inSingle = false
    // 如果之前标记了字符是处于双引号字符包裹中的，而当前字符是非转义的双引号，那么结束双引号标记
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) inDouble = false
    // 如果之前标记了字符是处于反引号字符包裹中的，而当前字符是非转义的反引号，那么结束反引号标记
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) inTemplateString = false
    // 如果之前标记了字符是处于正则表达式中的，而当前字符是非转义的斜杠，那么结束正则表达式标记
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) inRegex = false
    // 如果是管道符号 | ，并且其前、后的字符都不是 | （排除 || ），
    // 并且花括号、方括号、圆括号的嵌套层数都为零，那么进一步判断处理
    // 这里看出管道符号只能用于最外层，即没有括号嵌套的，这里是绑定属性值的表达式，故不会出现双花括号包裹的形式{{}}
    // 管道符号后面跟着格式化函数filter
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      // 第一次进入这里时，expression必定是undefined的
      // 假如expression是undefined，那么表示表达式结束了，管道符号后面是过滤器函数，前面是一个完整的表达式
      if (expression === undefined) {
        // first filter, end of expression
        // 记录下一个过滤器函数起始位置
        lastFilterIndex = i + 1
        // 保存表达式
        expression = exp.slice(0, i).trim()
      // 如果expression不是undefined，即出现连环过滤的情况,那么两个管道符之间的字符串就是一个完整的过滤器函数标识符
      // 把标识符进栈保存，记录下一个过滤器函数的起始位置
      } else {
        pushFilter()
      }
    } else {
      // 判断是否是特定的字符，并对其做特定的处理, c=== 0x2f处理步骤较多，故把它以if代码块的形式放switch外面了
      switch (c) {
        // 如果是双引号，标记接下来的字符都是在双引号里
        case 0x22: inDouble = true; break         // "
        // 如果是单引号，标记接下来的字符都是在单引号里
        case 0x27: inSingle = true; break         // '
        // 如果是反引号，标记接下来的字符都是在反引号里
        case 0x60: inTemplateString = true; break // `
        // 如果是左圆括号，圆括号嵌套层数加1
        case 0x28: paren++; break                 // (
        // 如果是右圆括号，圆括号嵌套层数减1
        case 0x29: paren--; break                 // )
        // 如果是左方括号，方括号嵌套层数加1
        case 0x5B: square++; break                // [
        // 如果是右方括号，方括号嵌套层数减1
        case 0x5D: square--; break                // ]
        // 如果是左花括号，花括号嵌套层数加1
        case 0x7B: curly++; break                 // {
        // 如果是右花括号，花括号嵌套层数减1
        case 0x7D: curly--; break                 // }
      }
      // 如果是斜杠，进一步判断
      if (c === 0x2f) { // /
        let j = i - 1
        let p
        // find first non-whitespace prev char
        // 获取当前 c 之前的第一个非空格的字符
        for (; j >= 0; j--) {
          p = exp.charAt(j)
          if (p !== ' ') break
        }
        // 如果p不存在，或者p存在但p可以作为正则的分隔符，那么标记接下来的字符是正则的一部分
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true
        }
      }
    }
    // 继续循环体的下一轮循环判断
  }

  // 经过循环体的判断，expression保存着纯表达式，filters保存着过滤器函数

  // 如果expression仍为undefined，那么就是循环体中没有匹配到管道字符，也就没有对expression进行赋值
  // 此时 i 是原始字符串exp中最后一个字符的下标,即把整个exp去掉头尾空格当作expression
  if (expression === undefined) {
    expression = exp.slice(0, i).trim()
  // 如果expression不为undefined，则循环体中匹配到了管道字符，过滤器函数的标识符是通过两管道字符来确定的，
  // 最后一个过滤器函数标志符需后没有跟管道字符的，需截取到exp的末尾,
  // 即把lastFilterIndex到i之间的字符都当作最后一个过滤器函数的标识符了
  } else if (lastFilterIndex !== 0) {
    pushFilter()
  }
  // 把过滤器函数的标志进栈保存，更改记录下一个过滤器函数的起始位置
  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim())
    lastFilterIndex = i + 1
  }
  // 如果存在过滤器函数，那么把expression经过过滤器函数一个个做转换包装
  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i])
    }
  }
  // 返回最终的表达式
  return expression
}
// 把exp经过filter函数转换，返回转换后的值
function wrapFilter (exp: string, filter: string): string {
  // 使用过滤器函数时可带参数或不带，如：message | filterA('arg1', arg2)
  // filterA接收三个参数，message作为第一个参数，'arg1'作为第二个，以此类推
  // 这里先判断过滤器是否带了其他参数
  // 如果filter不含其他参数，直接用内置的_f函数包装返回
  // _f 即 Vue.protoType._f
  const i = filter.indexOf('(')
  if (i < 0) {
    // _f: resolveFilter
    return `_f("${filter}")(${exp})`
  // 如果filter包含其他参数，把其他参数一起包装返回
  } else {
    const name = filter.slice(0, i)
    const args = filter.slice(i + 1)
    return `_f("${name}")(${exp}${args !== ')' ? ',' + args : args}`
  }
}
