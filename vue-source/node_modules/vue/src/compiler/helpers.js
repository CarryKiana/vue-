/* @flow */
// emptyObject是一个空的被冻结的对象
import { emptyObject } from 'shared/util'
// parseFilters用于解析表达式，分析并装换其中的过滤器
import { parseFilters } from './parser/filter-parser'
// 默认的警告函数，单纯的把编译时发生的msg打印出来
export function baseWarn (msg: string) {
  console.error(`[Vue compiler]: ${msg}`)
}
// 提取模块对象中的function
// 就是返回modules每个对象元素上的key函数，过滤掉不存在的部分,即把每个对象上相应的函数整合取出
export function pluckModuleFunction<F: Function> (
  modules: ?Array<Object>,
  key: string
): Array<F> {
  return modules
    ? modules.map(m => m[key]).filter(_ => _)
    : []
}
// 为抽象语法树的节点添加props属性，同时表明节点el不是单纯的语法树节点（混入了一些自定义的prop属性）
export function addProp (el: ASTElement, name: string, value: string) {
  (el.props || (el.props = [])).push({ name, value })
  el.plain = false
}
// 为抽象语法树的节点添加attr属性，同时表明节点el不是单纯的语法树节点（混入了一些自定义的attr属性）
export function addAttr (el: ASTElement, name: string, value: any) {
  (el.attrs || (el.attrs = [])).push({ name, value })
  el.plain = false
}

// add a raw attr (use this in preTransforms)
// 为抽象语法树的节点el添加一个原始属性（会在转换前使用）
export function addRawAttr (el: ASTElement, name: string, value: any) {
  el.attrsMap[name] = value
  el.attrsList.push({ name, value })
}
// 为抽象语法树节点el添加指令
export function addDirective (
  el: ASTElement,
  name: string,
  rawName: string,
  value: string,
  arg: ?string,
  modifiers: ?ASTModifiers
) {
  (el.directives || (el.directives = [])).push({ name, rawName, value, arg, modifiers })
  el.plain = false
}
// 根据绑定的修饰符为抽象语法树节点添加相应的处理方法
// 修饰符有事件修饰符、按键修饰符、系统修饰键等，分门别类进行判断
// 事件修饰符(可以看一下addEventLister的相关option配置,capture,once,passive俱全)：
// .stop: 阻止冒泡（阻止事件向上级dom元素传递）
// .prevent: 阻止默认事件的发生（dom操作会引起浏览器自动执行某些操作，如点击超链接发生的自动跳转，点击表单提交按钮时重新加载页面等）
// .capture: 事件于捕获阶段就执行，有事件发生时，先执行又该修饰符的dom元素上绑定的事件（dom2事件流：捕获阶段-冒泡阶段）,有此修饰符的事件在捕获阶段就被执行
// .self: 将事件绑定到自身，即只有触发事件的目标是绑定的dom元素时，才会执行该事件，用于避免冒泡事件的影响
// .once: 事件只会触发一次
// .passive: 能够提升移动端性能（没试过），addEventLister用来忽略perventDefault()，表示侦听器永远不会调用perventDefault()
// 鼠标按钮修饰符：限制处理函数仅响应特定的鼠标事件
// .left: 左键 , 左键事件好像没被规范化处理，甚至都没有被处理
// .right: 右键
// .middle: 滚轮
// 特定修饰符：
// .native: 将事件绑定到组件的根元素上
export function addHandler (
  el: ASTElement,
  name: string,
  value: string,
  modifiers: ?ASTModifiers,
  important?: boolean,
  warn?: Function
) {
  // 防错处理，不存在修饰符对象时赋值空对象
  modifiers = modifiers || emptyObject
  // warn prevent and passive modifier
  // prevent跟passive不能放在一起
  /* istanbul ignore if */
  if (
    process.env.NODE_ENV !== 'production' && warn &&
    modifiers.prevent && modifiers.passive
  ) {
    // prevent阻止默认事件，passive忽略阻止默认事件，放一起会警告
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.'
    )
  }
  // 注意处理顺序：capture、once、passive，name = !~& name
  // check capture modifier
  // 检查是否有capture，有的话删掉这个属性（处理过了不会被重复处理），用!标记
  if (modifiers.capture) {
    delete modifiers.capture
    name = '!' + name // mark the event as captured
  }
  // 检查是否有once，有的话删掉这个属性（处理过了不会被重复处理），用~标记
  if (modifiers.once) {
    delete modifiers.once
    name = '~' + name // mark the event as once
  }
  // 检查是否有passive,有的话删掉这个属性（处理过了不会被重复处理），用&标记
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive
    name = '&' + name // mark the event as passive
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  // 规范化鼠标右键跟滚轮事件，尽管他们实际上不会触发，
  // 从技术上来讲，这是特定于浏览器（环境）的,但不管怎样现代浏览器是唯一具有这些事件的目标环境
  // 鼠标点击事件click，表示鼠标右键的事件是click.right，匹配到的话会转换为实际的事件名，比如右键转为contextmenu事件
  // 奇怪的是右键处理完会delete掉属性，滚轮转换为mouseup后竟然不会delete，为什么？
  if (name === 'click') {
    if (modifiers.right) {
      name = 'contextmenu'
      delete modifiers.right
    } else if (modifiers.middle) {
      name = 'mouseup'
    }
  }

  let events
  // 如果修饰符上存在native（表明事件需要挂到组件的根元素上），缓存nativeEvent事件，否则，缓存el上的event事件到events变量上
  // 同时在events变量上做的修改也相当于在el.nativeEvents或el.events上的修改
  if (modifiers.native) {
    delete modifiers.native
    events = el.nativeEvents || (el.nativeEvents = {})
  } else {
    events = el.events || (el.events = {})
  }
  // 规范化处理方法，传入的value应该是一个函数的函数体字符串（经过编译转换而来）
  const newHandler: any = {
    value: value.trim()
  }
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers
  }
  // handlers是原先对应事件的处理方法（集）
  const handlers = events[name]
  // 如果原先的事件方法handlers是数组,根据当前的事件方法是否具有优先级important，把当前事件方法放于事件数组的开头或末尾
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler)
  // 如果handlers不是数组但存在，与当前事件方法组成数组，由important决定是放于数组开头或末尾
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler]
  // 如果handlers不存在，直接把当前的处理方法赋予相应的事件
  } else {
    events[name] = newHandler
  }
  // 标记el节点
  el.plain = false
}
// 获取绑定的属性，之后解析它
export function getBindingAttr (
  el: ASTElement,
  name: string,
  getStatic?: boolean
): ?string {
  // 获取绑定的属性,getAndRemoveAttr获取后会删掉el上attrsList中相应的属性，这样属性不会重复获取
  const dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name)
  // 如果值存在，解析并返回解析的值
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  // 如果值不存在，而需要获取静态的属性，那么尝试获取el上对应的静态属性值
  } else if (getStatic !== false) {
    const staticValue = getAndRemoveAttr(el, name)
    // 静态属性值存在，序列化后返回
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
// 注意： 这只会从attrsList数组删除属性，这样它就不会被processAttrs处理
// 默认情况下，它不会从attrsMap中删除属性，因为在代码生成（codegen）期间需要attrsMap这个映射表
// 判断el.attrsMap上是否存在传入的name属性，存在时在el.attrList上把对应的属性删掉,返回那个属性值
export function getAndRemoveAttr (
  el: ASTElement,
  name: string,
  removeFromMap?: boolean
): ?string {
  let val
  if ((val = el.attrsMap[name]) != null) {
    const list = el.attrsList
    // 遍历属性查找属性有点low
    for (let i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1)
        break
      }
    }
  }
  // 如果指定要从attrsMap上删除属性，那就删除el.attrsMap上的相应属性
  if (removeFromMap) {
    delete el.attrsMap[name]
  }
  // 返回删除的那个属性值
  return val
}
